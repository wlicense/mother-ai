# マザーAI - 要件定義書

## 要件定義の作成原則
- **「あったらいいな」は絶対に作らない**
- **拡張可能性のための余分な要素は一切追加しない**
- **将来の「もしかして」のための準備は禁止**
- **今、ここで必要な最小限の要素のみ**

## 法令遵守・承認プロセス原則
- **著作権法その他法令違反の禁止**: BlueLampなどのアイデアを参考にするのはOKだが、著作権侵害・商標侵害・その他法令違反は絶対に行わない
- **料金発生時の承認プロセス（必須）**:
  1. 料金が発生するサービス利用・契約の前に、必ずユーザーの了承を得る
  2. さらにダブルチェックとして「本当に宜しいですか？」と念押しの承認も得る
  3. 承認なしに料金が発生する操作は一切行わない

---

## 1. プロジェクト概要

### 1.1 成果目標

非エンジニアがAI駆動開発プラットフォーム「マザーAI」を通じて、フリーランスエンジニア向けの大規模案件（数百万円報酬）を要件定義からデプロイまで完遂し、クライアントに納品できる状態を実現する。

**革新的特徴:**
- **自己改善・自己拡張機能**: マザーAI自身が自分のコードを読み取り、改善・拡張を自動実装
- **完全初心者対応**: パソコン操作は可能だが開発経験ゼロのユーザーが対象
- **BlueLamp風PhaseカードUI**: ワンクリックで各Phaseの専門エージェントが起動
- **AI対話だけで完結**: コーディング知識不要、対話のみで案件完遂

### 1.2 成功指標

#### 定量的指標

1. **技術的完遂能力**: エージェントと対話しながら進めることで、着手した案件を納品レベルまで完成させる
   - **目標: 100%**（どんな問題もエージェントが解決策を提示）

2. **ユーザー継続率**: ユーザーが途中で諦めずに最後まで使い続ける割合
   - 目標: **80%以上**（UXの改善で向上）

3. **開発期間**: 従来エンジニアが3ヶ月かかる案件を **1ヶ月以内**に完成

4. **品質スコア**: 生成されたコードのバグ発生率 **5%以下**
   - 全バグは自動検出・修正支援により解決可能

5. **平均案件単価**: ユーザーが受注できる案件の平均単価 **100万円以上**

#### 定性的指標

1. **非技術者でも直感的に操作できる**: プログラミング知識ゼロでもガイドに従えば完成できる
2. **クライアントが満足する品質**: 納品物がプロのエンジニアが作ったレベルと遜色ない
3. **学習曲線が緩やか**: 初めてのユーザーでも1週間以内に1件目の案件に着手できる
4. **安心感のあるサポート**: 困ったときにAI相談機能で即座に解決策が得られる
5. **プロフェッショナルとしての自信**: ユーザーが「自分もエンジニアとして活動できる」と感じられる

---

## 2. システム全体像

### 2.1 主要機能一覧

- **プロジェクト管理**: 複数案件の並行管理、進捗可視化
- **AI駆動開発**: Phase別専門エージェントとの対話による自動開発
- **自己改善システム**: マザーAI自身が自分のコードを解析・改善・拡張
- **承認制ユーザー管理**: 品質の高いユーザーコミュニティの構築
- **API監視・コスト管理**: 料金爆発を防ぐリアルタイム監視

### 2.2 ユーザーロールと権限

**ゲスト（未登録）:**
- ランディングページ閲覧
- 申請フォームへのアクセス
- デモ・機能紹介の閲覧

**申請中ユーザー (pending):**
- 審査待ち状態
- ログイン不可
- 審査状況の確認のみ

**一般ユーザー (approved):**
- プロジェクト作成・管理（無制限）
- AIエージェントとの対話
- コード生成・編集
- 自動デプロイ実行
- 自分のプロジェクトのみアクセス可能
- API使用量の確認

**停止中ユーザー (suspended):**
- 不正利用等で一時停止
- ログイン不可
- 再審査により復帰可能

**管理者 (admin):**
- 申請審査（承認/却下）
- 全ユーザー・プロジェクトの閲覧
- ユーザーステータス変更
- API使用量の監視・アラート設定
- 不正利用の検出・対応
- システム統計の確認

### 2.3 認証・認可要件

**認証方式:**
- メールアドレス + パスワード（必須）
- Google OAuth（推奨）
- GitHub OAuth（開発者向け）

**登録フロー（承認制）:**
1. ユーザーが申請フォームに記入（利用目的、経験レベル等）
2. 管理者が申請内容を審査
3. 承認後、メール通知 → ログイン可能
4. 却下の場合、理由を記載して通知

**セキュリティレベル:**
- **高**: APIキー（暗号化保存）、決済情報、生成コード
- **中**: プロジェクト情報、対話履歴、デプロイ設定
- **低**: ユーザープロフィール、公開統計情報

**承認制の利点:**
- API料金の爆発的増加を防止
- 品質の高いユーザーコミュニティ
- 不正利用・スパムの事前排除
- 真剣なユーザーのみが集まる

---

## 3. ページ詳細仕様

### 3.1 P-001: ランディングページ

**ルート:** `/`
**権限:** ゲスト
**優先度:** 高

#### 目的
マザーAIの価値を非エンジニアに伝え、申請を促す

#### 主要機能
- サービス説明（非エンジニアが数百万円案件を完遂できる）
- デモ動画・スクリーンショット
- 成功事例（将来的に追加）
- 「申請する」CTA（Call To Action）
- ログインリンク
- 料金プラン説明（将来的に追加）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 閲覧 | ページ情報の表示 | なし | サービス説明、デモ |
| 遷移 | 申請フォームへ | なし | P-002へ遷移 |
| 遷移 | ログインページへ | なし | P-003へ遷移 |

#### 処理フロー
1. ユーザーがアクセス
2. サービス説明、デモ動画を表示
3. 「申請する」ボタンクリック → P-002へ遷移

---

### 3.2 P-002: 申請フォーム

**ルート:** `/apply`
**権限:** ゲスト
**優先度:** 高

#### 目的
ユーザー情報を収集し、審査のための情報を取得

#### 主要機能
- 基本情報入力（メール、氏名、パスワード）
- 利用目的の記入（自由記述）
- 経験レベル選択（完全初心者/HTML/CSS経験あり/その他）
- どこでマザーAIを知ったか（SNS/検索/紹介等）
- OAuth連携オプション（Google/GitHub）
- 申請送信
- バリデーション（メール形式、パスワード強度等）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 作成 | 申請データ送信 | メール、氏名、パスワード、利用目的等 | 申請完了メッセージ、P-007へ遷移 |

#### 処理フロー
1. ユーザーがフォーム記入
2. バリデーション実行
3. 申請データをDBに保存（status: pending）
4. 管理者に通知メール送信
5. ユーザーに「審査中」メッセージ表示
6. P-007（審査待ちページ）へ遷移

#### データ構造（概念）
```yaml
Application:
  識別子: application_id（UUID）
  基本情報:
    - email（必須、ユニーク）
    - name（必須）
    - password_hash（必須、暗号化）
  審査情報:
    - purpose（利用目的、必須）
    - experience_level（経験レベル、必須）
    - referral_source（どこで知ったか、任意）
    - oauth_provider（Google/GitHub/null、任意）
  メタ情報:
    - status（pending/approved/rejected）
    - created_at
    - reviewed_at（審査日時）
    - rejection_reason（却下理由、任意）
  関連:
    - User（承認後に作成される）
```

---

### 3.3 P-003: ログインページ

**ルート:** `/login`
**権限:** ゲスト
**優先度:** 高

#### 目的
承認済みユーザーの認証

#### 主要機能
- メール/パスワードログイン
- Google OAuth ログイン
- GitHub OAuth ログイン
- パスワード忘れリンク
- エラーメッセージ表示（認証失敗、アカウント停止等）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 認証 | ログイン | メール、パスワード | JWT トークン、P-004へ遷移 |
| 認証 | OAuth ログイン | OAuth プロバイダ選択 | JWT トークン、P-004へ遷移 |

#### 処理フロー
1. ユーザーが認証情報を入力
2. バックエンドで認証
3. ステータスチェック:
   - approved → JWT発行、P-004へ
   - pending → 「審査中です」メッセージ、P-007へ
   - rejected → 「却下されました」メッセージ
   - suspended → 「アカウント停止中」メッセージ
4. 認証失敗 → エラーメッセージ表示

---

### 3.4 P-004: プロジェクト一覧・管理

**ルート:** `/projects`
**権限:** 一般ユーザー
**優先度:** 高

#### 目的
案件プロジェクトの作成・管理のハブ

#### 主要機能
- プロジェクト一覧表示（カード形式）
- 新規プロジェクト作成ボタン
- プロジェクト削除
- プロジェクト詳細へ遷移
- 進捗状況の可視化（Phase進行度、完了数/総数）
- 最終更新日時表示
- 検索・フィルター機能（将来的に追加）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | プロジェクト一覧取得 | ユーザーID（JWT） | プロジェクトリスト |
| 作成 | 新規プロジェクト作成 | プロジェクト名 | プロジェクトID、P-005へ遷移 |
| 削除 | プロジェクト削除 | プロジェクトID | 削除完了メッセージ |
| 遷移 | プロジェクト詳細へ | プロジェクトID | P-005へ遷移 |

#### 処理フロー
1. ユーザーがアクセス（ログイン後デフォルトページ）
2. ユーザーのプロジェクト一覧を取得・表示
3. 「新規作成」ボタンクリック
   - プロジェクト名入力モーダル表示
   - 作成 → P-005へ遷移
4. プロジェクトカードクリック → P-005へ遷移

#### データ構造（概念）
```yaml
Project:
  識別子: project_id（UUID）
  基本情報:
    - name（プロジェクト名、必須）
    - description（説明、任意）
    - owner_id（ユーザーID、必須）
  進捗情報:
    - current_phase（現在のPhase番号）
    - completed_phases（完了したPhase一覧）
    - progress_percentage（進捗率）
  メタ情報:
    - created_at
    - updated_at
    - deployed_url（デプロイURL、任意）
  関連:
    - User（所有者）
    - ChatHistory（対話履歴、1対多）
    - GeneratedCode（生成コード、1対多）
```

---

### 3.5 P-005: AI対話・プロジェクト開発（統合ページ）

**ルート:** `/projects/:id`
**権限:** 一般ユーザー
**優先度:** 高（マザーAIの中核機能）

#### 目的
マザーAIの核心機能 - AI対話による開発の完遂

#### 主要機能

**上部（Phaseカードグリッド）:**
- BlueLamp風Phaseカード表示（2行×2列、MVP: 4 Phase）
- Phase 1: 要件定義エージェント
- Phase 2: コード生成エージェント
- Phase 3: デプロイエージェント
- Phase 4: 自己改善エージェント（マザーAI専用）
- 各カードにアイコン、Phase名、説明、ステータス表示
- 現在のPhaseをハイライト
- 完了したPhaseにチェックマーク
- 次に進めるPhaseのみクリック可能（シーケンシャル）
- カードクリック → そのPhase専用エージェント起動

**下部（チャット/ターミナルエリア）:**
- リアルタイムAI対話（SSEストリーミング）
- ユーザーメッセージ入力欄
- AI応答の逐次表示
- コード生成進捗表示
- エラーメッセージ表示
- コマンド実行結果表示

**右サイドバー（トグル可能）:**
- ファイルツリー表示
- 生成されたコードのプレビュー
- Monaco Editor（必要時に展開してコード編集）
- デプロイステータス表示

**プロジェクト設定:**
- プロジェクト名変更
- 削除確認

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | プロジェクト詳細取得 | プロジェクトID | プロジェクト情報、Phase進捗 |
| 取得 | 対話履歴取得 | プロジェクトID | チャット履歴 |
| 作成 | メッセージ送信 | ユーザーメッセージ、Phase番号 | AI応答（SSEストリーミング） |
| 作成 | コード生成 | 要件情報 | 生成コード、ファイル一覧 |
| 更新 | コード編集 | ファイルパス、新コード | 更新完了 |
| 実行 | デプロイ | プロジェクトID | デプロイURL |
| 更新 | Phase完了 | Phase番号 | 次Phaseの解放 |

#### 処理フロー

**初回アクセス時:**
1. プロジェクト情報を取得
2. PhaseカードグリッドをPhase 1のみ有効で表示
3. チャットエリアに「Phase 1: 要件定義を開始しましょう」メッセージ
4. 要件定義エージェント起動

**Phaseカードクリック時:**
1. 選択されたPhaseの専門エージェントを起動
2. チャットエリアに遷移メッセージ表示
3. そのPhaseに適した対話を開始

**AI対話時:**
1. ユーザーがメッセージ入力・送信
2. メッセージをDBに保存
3. Claude APIにリクエスト（SSE）
4. AI応答をリアルタイムストリーミング表示
5. プロンプトキャッシング適用（コスト削減）
6. 応答をDBに保存

**コード生成時（Phase 2）:**
1. 要件情報を基にプロンプト構築
2. Claude APIでコード生成
3. 生成コードをファイルシステムに保存
4. ファイルツリー更新
5. Monaco Editorでプレビュー表示

**Phase完了時:**
1. ユーザーが「次へ」ボタンクリック
2. 現在のPhaseを完了マーク
3. 次のPhaseを有効化
4. 次のPhase専用エージェント起動

**デプロイ時（Phase 3）:**
1. 生成コードをGitHubにプッシュ
2. Vercel/GCRへ自動デプロイ（GitHub Actions）
3. デプロイステータスをリアルタイム表示
4. デプロイURL取得・表示

#### データ構造（概念）
```yaml
ChatMessage:
  識別子: message_id（UUID）
  基本情報:
    - project_id（必須）
    - role（user/assistant/system）
    - content（メッセージ内容）
    - phase_number（どのPhaseの対話か）
  メタ情報:
    - created_at
    - tokens_used（使用トークン数）
  関連:
    - Project（所属プロジェクト）

GeneratedCode:
  識別子: code_id（UUID）
  基本情報:
    - project_id（必須）
    - file_path（ファイルパス）
    - content（コード内容）
    - language（プログラミング言語）
  メタ情報:
    - created_at
    - updated_at
  関連:
    - Project（所属プロジェクト）

PhaseProgress:
  識別子: progress_id（UUID）
  基本情報:
    - project_id（必須）
    - phase_number（Phase番号）
    - status（locked/available/in_progress/completed）
  メタ情報:
    - started_at
    - completed_at
  関連:
    - Project（所属プロジェクト）
```

---

### 3.6 P-006: マイプロフィール・設定

**ルート:** `/profile`
**権限:** 一般ユーザー
**優先度:** 中

#### 目的
ユーザー情報とAPIキーの管理

#### 主要機能
- プロフィール編集（氏名、メール）
- APIキー設定（Claude API）
- 外部サービス連携設定（Google/GitHub OAuth）
- API使用量の確認（月次、プロジェクト別）
- パスワード変更
- アカウント削除（確認モーダル）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | ユーザー情報取得 | ユーザーID（JWT） | プロフィール情報 |
| 更新 | プロフィール更新 | 氏名、メール | 更新完了 |
| 更新 | APIキー設定 | Claude APIキー | 暗号化保存完了 |
| 取得 | API使用量取得 | ユーザーID | 月次使用量、コスト |
| 更新 | パスワード変更 | 現在PW、新PW | 更新完了 |
| 削除 | アカウント削除 | パスワード確認 | 削除完了 |

#### 処理フロー
1. ユーザーがアクセス
2. プロフィール情報を取得・表示
3. 各種設定を変更
4. 保存ボタンクリック → バックエンドで更新
5. 成功メッセージ表示

#### データ構造（概念）
```yaml
User:
  識別子: user_id（UUID）
  基本情報:
    - email（ユニーク、必須）
    - name（必須）
    - password_hash（暗号化、必須）
  API設定:
    - claude_api_key_encrypted（暗号化保存）
    - api_usage_limit（月次制限、任意）
  OAuth連携:
    - google_oauth_id（任意）
    - github_oauth_id（任意）
  メタ情報:
    - status（approved/suspended）
    - created_at
    - last_login_at
  統計:
    - total_projects（プロジェクト数）
    - total_api_usage（累計トークン使用量）
  関連:
    - Projects（所有プロジェクト、1対多）
    - APIUsageLog（使用量ログ、1対多）
```

---

### 3.7 P-007: 審査待ちページ

**ルート:** `/pending`
**権限:** 申請中ユーザー
**優先度:** 中

#### 目的
申請中ユーザーへの案内

#### 主要機能
- 「審査中です」メッセージ
- 審査にかかる時間の目安（通常1-3営業日）
- 問い合わせ先メールアドレス
- よくある質問（FAQ）
- 申請内容の確認（編集不可）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | 申請情報取得 | ユーザーID（JWT） | 申請内容 |
| 閲覧 | 審査状況確認 | なし | 「審査中」メッセージ |

#### 処理フロー
1. 申請中ユーザーがログイン試行
2. ステータスチェック（pending）
3. このページへ自動遷移
4. 審査状況を表示

---

### 3.8 A-001: 申請審査ダッシュボード

**ルート:** `/admin/applications`
**権限:** 管理者
**優先度:** 高

#### 目的
申請を効率的に審査

#### 主要機能
- 申請一覧（pending状態のユーザー）
- 申請詳細表示（モーダル or サイドパネル）
- 承認ボタン
- 却下ボタン + 却下理由入力
- メール通知機能（承認/却下自動送信）
- フィルター（日付、ステータス）
- 統計表示（申請数、承認率、却下数）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | 申請一覧取得 | ステータス=pending | 申請リスト |
| 更新 | 申請承認 | application_id | ユーザー作成、メール送信 |
| 更新 | 申請却下 | application_id、却下理由 | ステータス更新、メール送信 |
| 取得 | 統計取得 | 期間 | 申請数、承認率等 |

#### 処理フロー

**承認時:**
1. 管理者が申請詳細を確認
2. 「承認」ボタンクリック
3. Application.status を approved に更新
4. User レコード作成（Application情報をコピー）
5. 承認メール送信（ログイン情報含む）
6. 一覧から削除（pending一覧から消える）

**却下時:**
1. 管理者が申請詳細を確認
2. 「却下」ボタンクリック
3. 却下理由入力モーダル表示
4. Application.status を rejected、理由を保存
5. 却下メール送信（理由含む）
6. 一覧から削除

#### データ構造（概念）
```yaml
Application:（P-002参照）
  審査情報追加:
    - reviewed_by（審査した管理者ID）
    - reviewed_at
    - rejection_reason
```

---

### 3.9 A-002: ユーザー・プロジェクト管理

**ルート:** `/admin/users`
**権限:** 管理者
**優先度:** 高

#### 目的
ユーザーとプロジェクトの監視・管理

#### 主要機能

**ユーザー管理:**
- 全ユーザー一覧（検索、フィルター）
- ユーザー詳細（プロジェクト数、API使用量）
- ステータス変更（approved ↔ suspended）
- ユーザー削除（確認モーダル）
- API使用量の詳細確認

**プロジェクト管理:**
- 全プロジェクト一覧
- プロジェクト詳細閲覧（コード内容含む）
- スパム・不正利用の検出（異常なAPI使用量等）
- プロジェクト削除（緊急時）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | 全ユーザー一覧 | フィルター条件 | ユーザーリスト |
| 取得 | ユーザー詳細 | user_id | 詳細情報、プロジェクト一覧 |
| 更新 | ステータス変更 | user_id、新ステータス | 更新完了 |
| 削除 | ユーザー削除 | user_id | 削除完了 |
| 取得 | 全プロジェクト一覧 | フィルター条件 | プロジェクトリスト |
| 取得 | プロジェクト詳細 | project_id | 詳細情報、コード内容 |
| 削除 | プロジェクト削除 | project_id | 削除完了 |

#### 処理フロー

**ユーザー停止時:**
1. 管理者が異常なAPI使用を検知
2. ユーザー詳細を確認
3. 「停止」ボタンクリック → 確認モーダル
4. User.status を suspended に更新
5. ユーザーにメール通知
6. 次回ログイン時、「停止中」メッセージ表示

**スパム検出時:**
1. プロジェクト一覧で異常なパターンを検出
   - 短時間に大量プロジェクト作成
   - 同じコード内容の繰り返し生成
2. プロジェクト詳細を確認
3. 該当プロジェクト削除
4. ユーザーを停止

#### データ構造（概念）
```yaml
AdminLog:（将来的に追加）
  識別子: log_id（UUID）
  基本情報:
    - admin_id（管理者ID）
    - action_type（approval/rejection/suspension/deletion）
    - target_id（対象のuser_id or project_id）
    - reason（理由）
  メタ情報:
    - created_at
```

---

### 3.10 A-003: API監視ダッシュボード

**ルート:** `/admin/api-monitor`
**権限:** 管理者
**優先度:** 高

#### 目的
API利用料金の爆発的増加を防ぐリアルタイム監視

#### 主要機能

**リアルタイム監視:**
- 現在のAPI使用量（トークン数、コスト）
- 日次/週次/月次の使用量グラフ
- ユーザー別API使用量ランキング
- プロジェクト別API使用量
- 異常検知アラート（急激な増加等）

**アラート設定:**
- 日次上限設定（$XXX/日）
- 月次上限設定（$XXX/月）
- ユーザー別上限設定
- アラートメール送信設定

**コスト分析:**
- トークン種別ごとの使用量（入力/出力/キャッシュヒット）
- モデル別使用量（Sonnet/Opus/Haiku）
- コスト削減効果の可視化（キャッシング効果等）

#### 必要な操作
| 操作種別 | 操作内容 | 必要な入力 | 期待される出力 |
|---------|---------|-----------|---------------|
| 取得 | リアルタイム使用量 | なし | 現在の使用量、コスト |
| 取得 | 使用量履歴 | 期間 | グラフデータ |
| 取得 | ユーザー別使用量 | なし | ランキングリスト |
| 更新 | アラート設定 | 上限値 | 設定保存完了 |
| 取得 | 異常検知 | なし | 異常なユーザー/プロジェクト |

#### 処理フロー

**通常監視:**
1. ダッシュボードにアクセス
2. リアルタイムデータを取得・表示（自動更新）
3. グラフで視覚的に確認

**異常検知時:**
1. システムが異常なAPI使用を検知
2. アラートを表示（赤色ハイライト）
3. 管理者にメール通知
4. 該当ユーザー/プロジェクトの詳細を確認
5. 必要に応じて停止措置

**アラート設定:**
1. 「設定」タブをクリック
2. 各種上限値を入力
3. 保存 → システムが自動監視開始

#### データ構造（概念）
```yaml
APIUsageLog:
  識別子: log_id（UUID）
  基本情報:
    - user_id（必須）
    - project_id（必須）
    - message_id（関連メッセージ）
  使用量情報:
    - model（使用モデル: sonnet/opus/haiku）
    - input_tokens（入力トークン数）
    - output_tokens（出力トークン数）
    - cached_tokens（キャッシュヒット数）
    - cost_usd（コスト）
  メタ情報:
    - created_at
  関連:
    - User
    - Project
    - ChatMessage

APIAlert:（将来的に追加）
  識別子: alert_id（UUID）
  基本情報:
    - alert_type（daily_limit/monthly_limit/anomaly）
    - threshold（閾値）
    - current_value（現在値）
    - target_id（user_id or project_id）
  メタ情報:
    - created_at
    - resolved_at
    - notified（通知済みフラグ）
```

---

## 4. データ設計概要

### 4.1 主要エンティティ

```yaml
User:
  概要: システム利用者（承認済み）
  主要属性:
    - 基本情報: email、name、password_hash
    - API設定: claude_api_key_encrypted、api_usage_limit
    - OAuth: google_oauth_id、github_oauth_id
    - ステータス: status（approved/suspended）
  関連:
    - Projects（1対多）
    - APIUsageLog（1対多）

Application:
  概要: ユーザー申請データ
  主要属性:
    - 基本情報: email、name、password_hash
    - 審査情報: purpose、experience_level、referral_source
    - ステータス: status（pending/approved/rejected）
    - 審査結果: reviewed_at、rejection_reason
  関連:
    - User（承認後に作成、1対1）

Project:
  概要: ユーザーの案件プロジェクト
  主要属性:
    - 基本情報: name、description、owner_id
    - 進捗: current_phase、completed_phases、progress_percentage
    - 成果物: deployed_url
  関連:
    - User（所有者、多対1）
    - ChatMessage（対話履歴、1対多）
    - GeneratedCode（生成コード、1対多）
    - PhaseProgress（Phase進捗、1対多）

ChatMessage:
  概要: AI対話メッセージ
  主要属性:
    - 内容: project_id、role（user/assistant）、content
    - Phase: phase_number
    - 使用量: tokens_used
  関連:
    - Project（所属、多対1）

GeneratedCode:
  概要: 生成されたコードファイル
  主要属性:
    - ファイル情報: project_id、file_path、content、language
  関連:
    - Project（所属、多対1）

PhaseProgress:
  概要: Phase進捗管理
  主要属性:
    - Phase情報: project_id、phase_number
    - ステータス: status（locked/available/in_progress/completed）
    - 時間: started_at、completed_at
  関連:
    - Project（所属、多対1）

APIUsageLog:
  概要: API使用量ログ
  主要属性:
    - 対象: user_id、project_id、message_id
    - 使用量: model、input_tokens、output_tokens、cached_tokens、cost_usd
  関連:
    - User（多対1）
    - Project（多対1）
    - ChatMessage（多対1）
```

### 4.2 エンティティ関係図

```
User ─┬─ Application（1対1、承認前）
      ├─ Project（1対多）
      └─ APIUsageLog（1対多）

Project ─┬─ ChatMessage（1対多）
         ├─ GeneratedCode（1対多）
         ├─ PhaseProgress（1対多）
         └─ APIUsageLog（1対多）

ChatMessage ─── APIUsageLog（1対多）
```

### 4.3 バリデーションルール

```yaml
email:
  - ルール: 有効なメール形式、ユニーク
  - 理由: 通知送信とアカウント識別のため

password:
  - ルール: 8文字以上、英数字混在推奨
  - 理由: セキュリティ確保のため

name:
  - ルール: 1文字以上、100文字以内
  - 理由: 表示とコミュニケーションのため

project_name:
  - ルール: 1文字以上、200文字以内
  - 理由: 識別と管理のため

claude_api_key:
  - ルール: "sk-ant-" で始まる文字列
  - 理由: Claude API公式フォーマット

file_path:
  - ルール: 相対パス、".."を含まない
  - 理由: セキュリティ（ディレクトリトラバーサル防止）

code_content:
  - ルール: 10MB以内
  - 理由: パフォーマンスとストレージ制限
```

---

## 5. 制約事項

### 外部API制限

**Claude API:**
- **レート制限**:
  - Tier 1: 50リクエスト/分、40,000トークン/分
  - 超過時: 429エラー、自動リトライ実装
- **コンテキスト長**: 最大200Kトークン
- **コスト**:
  - Sonnet 4.5: $3（入力）/ $15（出力）per 100万トークン
  - プロンプトキャッシング利用で50%削減可能
- **対策**:
  - プロンプトキャッシング必須実装
  - 効率的なプロンプト設計
  - 将来的にOpenAI APIフォールバック追加

**Neon PostgreSQL:**
- **無料枠制限**: 0.5GB ストレージ
- **接続数**: 最大20並列接続
- **対策**:
  - MVP段階では十分
  - ユーザー増加時に有料プラン移行

**Vercel:**
- **無料枠制限**:
  - 100GB帯域幅/月
  - ビルド時間6,000分/月
- **対策**: 無料枠で十分、超過時にPro移行

**Google Cloud Run:**
- **無料枠制限**:
  - 240万リクエスト/月
  - CPU時間360,000vCPU秒/月
- **対策**: 無料枠で十分、超過時に従量課金

### 技術的制約

**コード生成:**
- **制限**: 1度に生成可能なファイル数〜50ファイル
- **理由**: Claude APIのコンテキスト長制限
- **対策**: 段階的な生成、ファイル分割

**デプロイ:**
- **制限**: GitHub Actions 月3,000分（無料枠）
- **理由**: CI/CD実行時間
- **対策**: デプロイ最適化、キャッシュ活用

**ファイルストレージ:**
- **制限**: MVP段階はローカルファイルシステム（GCR内）
- **理由**: シンプルさ優先
- **対策**: 後期にGoogle Cloud Storage移行

**リアルタイム通信:**
- **制限**: SSEは一方向（サーバー→クライアント）
- **理由**: 技術的仕様
- **対策**: クライアントからはHTTP POST、サーバーからはSSE

---

## 6. 複合API処理（バックエンド内部処理）

### 複合処理-001: AI対話によるコード生成

**トリガー**: ユーザーがPhase 2（コード生成）でメッセージ送信
**フロントエンドAPI**: POST /api/chat/send
**バックエンド内部処理**:
1. **対話履歴取得** - DBから過去の対話を取得（プロンプトキャッシング用）
2. **Claude API呼び出し** - SSEストリーミングでコード生成
3. **プロンプトキャッシング適用** - 同じコンテキストを再利用（50%コスト削減）
4. **生成コードの解析** - ファイルパス、言語を自動判定
5. **ファイルシステムに保存** - 生成コードをディレクトリ構造で保存
6. **DB保存** - ChatMessage、GeneratedCode、APIUsageLog に保存
7. **SSE応答** - リアルタイムでフロントエンドに送信

**結果**: 生成コード、ファイルツリー、API使用量
**外部サービス依存**: Claude API

### 複合処理-002: 自動デプロイ

**トリガー**: ユーザーがPhase 3（デプロイ）で「デプロイ」ボタンクリック
**フロントエンドAPI**: POST /api/deploy
**バックエンド内部処理**:
1. **コード整合性チェック** - 必須ファイルの存在確認（package.json等）
2. **GitHubリポジトリ作成** - GitHub API経由でリポジトリ作成
3. **コードプッシュ** - 生成コードをGitHubにプッシュ
4. **Vercel連携** - Vercel APIでプロジェクト作成、リポジトリ連携
5. **GitHub Actions起動** - CI/CDパイプラインを自動実行
6. **デプロイステータス監視** - ポーリングでステータス確認
7. **デプロイURL取得** - 本番環境URLを取得
8. **DB更新** - Project.deployed_url を更新

**結果**: デプロイURL、デプロイステータス
**外部サービス依存**: GitHub API、Vercel API、GitHub Actions

### 複合処理-003: マザーAI自己改善（Phase 4）

**トリガー**: ユーザーが「マザーAIを改善して」とリクエスト
**フロントエンドAPI**: POST /api/self-improve
**バックエンド内部処理**:
1. **マザーAI自身のコードを読み取る** - GitHubからソースコード取得
2. **Claude APIで解析** - バグ、パフォーマンス問題、改善点を検出
3. **改善案の生成** - 具体的なコード修正案を生成
4. **ユーザーに提示** - 改善案を説明文と共に表示
5. **ユーザー承認待ち** - ユーザーが承認するまで待機
6. **承認後、コード更新** - GitHubにプルリクエスト作成 or 直接コミット
7. **自動テスト実行** - GitHub Actionsでテスト
8. **本番反映** - テスト成功後、自動デプロイ

**結果**: 改善されたマザーAI、変更ログ
**外部サービス依存**: GitHub API、Claude API、GitHub Actions

### 複合処理-004: プロンプトキャッシング最適化

**トリガー**: 任意のAI対話時（自動）
**バックエンド内部処理**:
1. **キャッシュ可能コンテキスト判定** - プロジェクト情報、過去の対話等
2. **キャッシュキー生成** - プロジェクトIDベース
3. **Claude APIにキャッシュヘッダー付きリクエスト** - プロンプトキャッシング機能利用
4. **キャッシュヒット確認** - レスポンスからキャッシュ利用状況取得
5. **コスト計算** - 通常料金 vs キャッシュ料金を計算
6. **APIUsageLogに保存** - cached_tokens、削減コストを記録

**結果**: 50%コスト削減、高速化
**外部サービス依存**: Claude API（プロンプトキャッシング機能）

---

## 7. 技術スタック

### フロントエンド
- **フレームワーク**: React 18
- **言語**: TypeScript 5
- **UIライブラリ**: MUI v6 (Material-UI)
- **コードエディタ**: Monaco Editor（VS Codeと同じ）
- **状態管理**: Zustand（軽量・シンプル）
- **リアルタイム通信**: Server-Sent Events (SSE)
- **データフェッチ**: React Query
- **ルーティング**: React Router v6
- **ビルドツール**: Vite 5
- **認証**: NextAuth.js（メール/パスワード + OAuth）
- **ホスティング**: Vercel

### バックエンド
- **言語**: Python 3.11+
- **フレームワーク**: FastAPI
- **AI/LLM API**: Claude API (Anthropic) - メイン
- **マルチエージェント**: CrewAI（初心者向けで最適）
- **リアルタイム通信**: Server-Sent Events (SSE)
- **認証**: JWT（JSON Web Tokens）
- **ORM**: SQLAlchemy 2.0
- **データベース**: Neon PostgreSQL（サーバーレス）
- **ホスティング**: Google Cloud Run（サーバーレス）
- **CI/CD**: GitHub Actions

### データベース・ストレージ
- **メインDB**: Neon PostgreSQL
- **ファイルストレージ**:
  - MVP: ローカルファイルシステム（GCR内）
  - 後期: Google Cloud Storage
- **キャッシュ**:
  - MVP: なし
  - 後期: Redis（API料金削減、プロンプトキャッシング）

### インフラ・DevOps
- **フロントエンド**: Vercel（自動デプロイ、CDN）
- **バックエンド**: Google Cloud Run（サーバーレス、従量課金）
- **CI/CD**: GitHub Actions
- **モニタリング**:
  - MVP: 最小限（GCRログ、Vercelダッシュボード）
  - 後期: Sentry（エラートラッキング）

### 開発ツール
- **バージョン管理**: Git + GitHub
- **コードフォーマット**: Prettier + ESLint
- **テスト**:
  - フロント: Vitest + React Testing Library
  - バック: pytest
  - E2E: Playwright（後期）
- **API仕様**: OpenAPI 3.0（FastAPI自動生成）

### コスト最適化技術
1. **プロンプトキャッシング**: Claude API公式機能、50%削減
2. **効率的プロンプト設計**: 無駄な対話削減、20-30%削減
3. **モデル最適化**: タスク難易度で自動切り替え（将来）
4. **合計削減効果**: 58-67%、実質5-6万円/案件

---

## 8. 必要な外部サービス・アカウント

### 必須サービス（MVP: 10-14日）

| サービス名 | 用途 | 取得先 | 無料枠 | 料金 |
|-----------|------|--------|-------|------|
| **Claude API** | AIエージェント | https://console.anthropic.com | なし | $3-15/100万トークン |
| **Neon PostgreSQL** | データベース | https://neon.tech | あり（0.5GB） | 無料枠で十分 |
| **Vercel** | フロントエンド | https://vercel.com | あり | 無料枠で十分 |
| **Google Cloud** | バックエンド | https://cloud.google.com | あり（240万リクエスト/月） | 無料枠で十分 |
| **GitHub** | コード管理 | https://github.com | あり（3000分/月） | 無料枠で十分 |
| **Google OAuth** | ソーシャルログイン | https://console.cloud.google.com | 無料 | 無料 |
| **GitHub OAuth** | ソーシャルログイン | https://github.com/settings/developers | 無料 | 無料 |

### 推奨サービス（後期追加、マザーAI自身が実装）

| サービス名 | 用途 | 追加タイミング |
|-----------|------|--------------|
| **OpenAI API** | フォールバック、コスト最適化 | 信頼性・コスト最適化が必要な時 |
| **Redis（Upstash）** | キャッシュ強化 | プロンプトキャッシング強化時 |
| **Stripe** | 決済処理 | 課金機能実装時 |
| **Sentry** | エラートラッキング | 本格運用時 |
| **SendGrid** | メール送信 | 通知機能強化時 |
| **Google Cloud Storage** | ファイル保存 | プロジェクト数増加時 |

---

## 9. 今後の拡張予定

### マザーAI自身が実装する拡張機能

#### ユーザー向け機能
- プロジェクトテンプレート共有
- チーム協業機能（複数人で1プロジェクト）
- 詳細な利用統計ダッシュボード
- チュートリアル・ヘルプページ
- 公開ポートフォリオ機能

#### 管理者向け機能
- 収益ダッシュボード
- 詳細分析レポート
- 自動審査システム（機械学習）
- システム設定画面（A-004）

#### Phase拡張
- Phase 4: テストエージェント
- Phase 5: リファクタリングエージェント
- Phase 6: ドキュメント生成エージェント
- Phase 7-14+: ユーザーニーズに応じて無限拡張

#### 技術拡張
- モバイルアプリ対応（Flutter）
- AI/ML統合機能
- VSCode拡張機能
- OpenAI API統合（フォールバック）

#### 自己進化機能
- Web検索で最新技術をキャッチアップ
- 自発的なアップグレード
- ユーザー成功率データによる自己最適化
- バグの自己修正

---

## 10. MVP開発スケジュール（10-14日）

### Day 1-2: 基盤構築
- GitHubリポジトリ作成
- フロントエンド雛形（React + MUI）
- バックエンド雛形（FastAPI）
- Neon PostgreSQL接続
- 基本認証実装（JWT）

### Day 3-4: 認証・ユーザー管理
- P-002: 申請フォーム
- P-003: ログインページ
- P-007: 審査待ちページ
- A-001: 申請審査ダッシュボード
- メール通知機能

### Day 5-7: コア機能（AI対話）
- P-004: プロジェクト一覧
- P-005: AI対話・開発ページ（PhaseカードUI）
- Claude API統合
- SSEストリーミング実装
- Phase 1-3エージェント実装
- プロンプトキャッシング実装

### Day 8-9: 管理機能・デプロイ
- P-006: マイプロフィール
- A-002: ユーザー管理
- A-003: API監視ダッシュボード
- 自動デプロイ機能（Phase 3）
- Vercel/GCR連携

### Day 10: テスト・調整
- 統合テスト
- バグ修正
- パフォーマンス最適化
- ドキュメント整備

### Day 11-14: 自己改善機能・仕上げ
- Phase 4: 自己改善エージェント実装
- P-001: ランディングページ（最後に作成）
- 最終テスト
- 本番デプロイ
- ユーザー受け入れ準備

---

## 11. 重要な開発原則

### 最小限の実装
- 「あったらいいな」は作らない
- MVP（10-14日）に必要な機能のみ
- 後でマザーAI自身が拡張

### 自己改善・自己拡張
- マザーAI自身が自分のコードを読み取る
- バグを自己修正
- 新機能を自己実装
- 最新技術に自己対応

### 品質保証
- TypeScript strictモード必須
- 未使用の変数/import禁止
- エラーハンドリング必須
- API料金監視必須

### セキュリティ
- APIキー暗号化保存
- HTTPS通信必須
- SQLインジェクション対策
- XSS対策
- 承認制による不正利用防止

---

## 12. 階層的マルチエージェント構造への進化ロードマップ

### 12.1 ビジョン：組織型AI「マザーAI」

マザーAIは最終的に、**社長AI → 部長AI → 課長AI → 平社員AI** の階層構造を持つ組織型AIに進化します。

```
最終的な組織構造（6ヶ月後）:

                 🏢 CEO AI（社長）
                       │
  ┌────────┬────────┬────────┬────────┐
  │        │        │        │        │
要件定義本部 実装本部  品質本部  運用本部  進化本部
(部長AI)  (部長AI) (部長AI) (部長AI) (部長AI)
  │        │        │        │        │
┌─┴─┐  ┌─┴─┐  ┌─┴─┐    │        │
要件  ドメイン フロント バック テスト デバッグ デプロイ 新エージェント
分析  分析   エンド  エンド  課長  課長   課長   生成課長
課長  課長   課長    課長   AI    AI     AI     AI
│    │     │      │     │     │      │      │
[平社員AI群 20-30個][平社員AI群][平社員AI群][平社員AI群]

総エージェント数: 100個以上
```

### 12.2 段階的実装ロードマップ

#### Phase 1: MVP（10-14日）- シンプル構造

```yaml
構造:
  オーケストレーターAI（調整役）
    ↓
  Phase 1-4 エージェント（独立動作）

エージェント数: 5個
  - オーケストレーターAI
  - Phase 1: 要件定義エージェント
  - Phase 2: コード生成エージェント
  - Phase 3: デプロイエージェント
  - Phase 4: 自己改善エージェント

特徴:
  - シンプル、確実に動作
  - 10-14日で完成
  - 将来の拡張基盤を実装（重要）
```

#### Phase 2: 階層構造導入（30-60日後）

```yaml
構造:
  CEO AI（社長）
    ↓
  部長AI（4-6名）
    ↓
  課長AI（10-15名）
    ↓
  平社員AI（20-30名）

エージェント数: 40-50個

実装方法:
  - マザーAI自身が階層構造を自己実装
  - Phase 4（自己改善）の機能を使用
  - CrewAI の Hierarchical モードに移行

移行作業:
  - 設定ファイル(agents.yml)を更新
  - 新しい部長AI、課長AIのコード生成
  - 既存エージェントを階層に組み込み
  - 自動デプロイ
```

#### Phase 3: 完全な組織型AI（6ヶ月後）

```yaml
構造:
  社長AI統括の5本部制
    - 要件定義本部
    - 実装本部
    - 品質管理本部
    - 運用本部
    - 自己進化本部

エージェント数: 100個以上

特徴:
  - 各本部が独立して動作
  - 横断的な協調作業
  - 自律的な学習・進化
  - ユーザー独自エージェントの追加
  - エージェントマーケットプレイス

結果:
  - 真の「AI駆動開発」実現
  - 「マザーAI」の名に完全に相応しい
  - AIがAIを産み出すメタAI
```

### 12.3 MVP時点で実装する将来対応基盤（重要）

**目的:** 将来の階層構造への移行を容易にするため、MVPの時点で以下の基盤を実装します。

#### 1. エージェント抽象化層

```python
class BaseAgent(ABC):
    """
    全エージェントの基底クラス
    将来の階層構造を見据えた設計
    """
    def __init__(self, role, level):
        self.role = role
        self.level = level  # CEO/Director/Manager/Worker
        self.subordinates = []  # 将来の部下リスト（MVP: 空）
        self.can_delegate = True if level != "Worker" else False

    @abstractmethod
    def execute(self, task):
        """タスク実行"""
        pass

    def delegate(self, task, to_agent):
        """
        部下に委譲（将来使用）
        MVP: 未使用だがインターフェース定義
        """
        if self.can_delegate and to_agent in self.subordinates:
            return to_agent.execute(task)
        else:
            return self.execute(task)
```

#### 2. エージェント動的追加機能

```python
class AgentRegistry:
    """
    エージェントを動的に追加・管理
    Phase 4で新しいエージェントを追加可能に
    """
    _agents = {}

    @classmethod
    def register(cls, agent_name, agent_instance):
        cls._agents[agent_name] = agent_instance

    @classmethod
    def add_new_agent(cls, agent_code):
        """
        マザーAIが新しいエージェントを生成して追加
        Phase 2以降で使用
        """
        new_agent = exec_and_create_agent(agent_code)
        cls.register(new_agent.name, new_agent)
```

#### 3. 統一メッセージプロトコル

```typescript
interface AgentMessage {
  from: string;           // 送信元エージェント
  to: string;             // 宛先
  message_type: "request" | "response" | "delegation" | "report";
  content: string;
  task_id: string;        // タスク追跡
  parent_task_id?: string; // 将来の階層追跡用（MVP: null）
  metadata: {
    phase: number;
    priority: "high" | "medium" | "low";
  };
}
```

#### 4. 拡張可能データベーススキーマ

```sql
-- Agents テーブル（将来の階層構造対応）
CREATE TABLE agents (
    agent_id UUID PRIMARY KEY,
    agent_name VARCHAR NOT NULL,
    agent_type VARCHAR NOT NULL,
    role VARCHAR NOT NULL,
    level VARCHAR NOT NULL,       -- 'CEO', 'Director', 'Manager', 'Worker'
    parent_agent_id UUID,         -- 将来の上司ID（MVP: NULL）
    is_active BOOLEAN DEFAULT true,
    created_by VARCHAR DEFAULT 'system',
    created_at TIMESTAMP,
    config JSONB
);

-- MVP時点では parent_agent_id は NULL
-- Phase 2以降で活用
```

#### 5. 設定ファイルでエージェント定義

```yaml
# config/agents.yml
agents:
  orchestrator:
    role: "プロジェクト統括"
    level: "CEO"
    allow_delegation: true
    subordinates: []  # MVP: 空、Phase 2: ["requirements_director", ...]

  phase1_requirements:
    role: "要件定義"
    level: "Worker"  # Phase 2: "Manager"
    allow_delegation: false

# コードを変えずに設定ファイルで階層構造を変更可能
```

#### 6. ロギング・トレーシング基盤

```python
class AgentLogger:
    @staticmethod
    def log_task_start(agent_name, task_id, task_description):
        logger.info("task_started", agent=agent_name, task_id=task_id)

    @staticmethod
    def log_delegation(from_agent, to_agent, task_id):
        """将来の委譲ログ（MVP: 未使用だが定義）"""
        logger.info("task_delegated", from_agent=from_agent, to_agent=to_agent)
```

### 12.4 階層構造のメリット

```yaml
真のメタAI:
  - 社長AIが全体を統括
  - 各階層が専門性を発揮
  - AIがAIを産み出す

スケーラビリティ:
  - 新しい本部・部門を追加可能
  - 各階層を独立して拡張

専門性の向上:
  - 各AIが専門タスクに集中
  - 協調動作で高品質を実現

障害耐性:
  - 1つのAIが失敗しても他がカバー
  - 階層的なエラーハンドリング

学習・進化:
  - 各階層が独立して学習
  - 組織全体が進化
```

### 12.5 コスト管理

```yaml
懸念: エージェント数が増えるとAPI料金増加

対策:
  ✅ 必要なエージェントのみ起動（遅延初期化）
  ✅ プロンプトキャッシング徹底活用
  ✅ 軽いタスクは低コストモデル（Haiku）使用
  ✅ 並列処理で時間短縮

実質コスト:
  - MVP（5エージェント）: 5-6万円/案件
  - Phase 2（40エージェント）: 8-10万円/案件
  - Phase 3（100エージェント）: 10-15万円/案件

  → 適切な最適化で許容範囲内
```

### 12.6 自己拡張時の安全対策（重要）

**懸念事項:**
- 自動拡張時にウイルス/マルウェアを混入させるリスク
- 誤った拡張によるシステム破壊
- セキュリティホールの作り込み
- 意図しない動作の追加

**多層防御策:**

#### 1. サンドボックス環境での事前テスト（必須）

```yaml
仕組み:
  1. マザーAIが新しいエージェントコードを生成
  2. 本番環境には適用せず、隔離されたサンドボックスで実行
  3. 自動テストを実行（セキュリティスキャン、動作確認）
  4. 問題なければ次のステップへ

実装:
  - Docker コンテナで隔離環境を作成
  - ネットワーク制限（外部通信禁止）
  - リソース制限（CPU、メモリ上限）
  - タイムアウト設定（暴走防止）

検証項目:
  ✅ コードに危険な関数がないか（exec, eval等）
  ✅ 外部URLへのアクセスがないか
  ✅ ファイルシステムへの不正アクセスがないか
  ✅ 既存機能を破壊しないか
  ✅ メモリリークがないか
```

#### 2. 人間の承認フロー（必須）

```yaml
自動拡張の承認プロセス:

  Step 1: マザーAIが拡張案を生成
    - 新しいエージェントの説明
    - 追加される機能の詳細
    - 変更されるコードの差分表示
    - サンドボックステスト結果

  Step 2: ユーザー（管理者）に通知
    - メール/Slack/アプリ内通知
    - 詳細な説明と変更内容を提示

  Step 3: ユーザーが承認または却下
    - 承認: 次のステップへ
    - 却下: 拡張を中止、理由をログに記録
    - 保留: 一定期間後に自動却下

  Step 4: ダブルチェック（重要な変更のみ）
    - 「本当に宜しいですか？」と再確認
    - 重要度に応じた承認レベル設定

承認が必要な変更:
  🔴 Critical（必ず承認）:
    - データベーススキーマ変更
    - 認証・認可ロジックの変更
    - 外部APIとの新規連携
    - 料金が発生する機能の追加

  🟡 Medium（承認推奨）:
    - 新しいエージェントの追加
    - 既存エージェントの大幅変更
    - UIの大きな変更

  🟢 Low（自動承認可）:
    - バグ修正
    - パフォーマンス最適化
    - ログ出力の改善
```

#### 3. セキュリティスキャン（自動）

```python
# コード生成時に自動実行
class SecurityScanner:
    """
    生成されたコードの安全性をチェック
    """

    DANGEROUS_PATTERNS = [
        r'exec\(',           # 任意コード実行
        r'eval\(',           # 任意コード実行
        r'__import__',       # 動的インポート
        r'subprocess\.',     # シェルコマンド実行
        r'os\.system',       # シェルコマンド実行
        r'open\([^)]*[\'"]w', # ファイル書き込み（制限付き許可）
        r'requests\.get\(',  # 外部HTTP通信（ホワイトリスト必要）
        r'socket\.',         # ソケット通信
        r'pickle\.loads',    # 危険なデシリアライズ
    ]

    ALLOWED_DOMAINS = [
        'api.anthropic.com',
        'api.openai.com',
        # ホワイトリスト
    ]

    def scan(self, code: str) -> ScanResult:
        """
        危険なパターンをスキャン
        """
        violations = []

        for pattern in self.DANGEROUS_PATTERNS:
            if re.search(pattern, code):
                violations.append(f"Dangerous pattern found: {pattern}")

        # 外部URLのチェック
        urls = extract_urls(code)
        for url in urls:
            if not self.is_whitelisted(url):
                violations.append(f"Unauthorized URL: {url}")

        return ScanResult(
            is_safe=(len(violations) == 0),
            violations=violations
        )
```

#### 4. バージョン管理とロールバック（必須）

```yaml
仕組み:
  - すべての変更をGitで管理
  - 各拡張を個別のコミット/ブランチで実装
  - タグ付けでバージョン管理
  - ワンクリックでロールバック可能

バージョン管理:
  v1.0.0: MVP リリース
  v1.1.0: Phase 5エージェント追加
  v1.2.0: フロントエンド課長AI追加

ロールバック手順:
  1. 管理画面で「バージョン履歴」を表示
  2. 問題のあるバージョンを特定
  3. 「v1.1.0にロールバック」ボタンをクリック
  4. 自動的に以前の状態に復元
  5. ユーザーに通知

自動ロールバック:
  - エラー率が閾値を超えた場合
  - API料金が異常に増加した場合
  - ユーザーからの苦情が一定数を超えた場合
  → 自動的に前のバージョンに戻す
```

#### 5. 変更内容の詳細ログ（監査証跡）

```yaml
記録内容:
  - 誰が（マザーAI or ユーザー）
  - いつ（タイムスタンプ）
  - 何を（変更内容の詳細）
  - なぜ（変更理由）
  - 結果（成功/失敗/ロールバック）

ログ例:
  {
    "timestamp": "2025-11-15T10:30:00Z",
    "initiated_by": "mother_ai",
    "change_type": "add_new_agent",
    "agent_name": "frontend_manager",
    "reason": "ユーザーリクエスト: フロントエンド実装の細分化",
    "approval_status": "approved",
    "approved_by": "user_admin_001",
    "sandbox_test_result": "passed",
    "security_scan_result": "safe",
    "deployment_status": "success",
    "rollback_point": "v1.1.0"
  }

監査機能:
  - 管理画面で全変更履歴を閲覧
  - 不審な変更を即座に検知
  - 外部監査への対応
```

#### 6. 外部依存関係のチェック

```yaml
問題:
  - マザーAIが勝手に外部ライブラリをインストール
  - ウイルスを含む悪意あるパッケージの混入

対策:
  ✅ 外部ライブラリのホワイトリスト制
  ✅ 新しいライブラリは必ず承認必要
  ✅ npm/pip パッケージのセキュリティスキャン
  ✅ 信頼できるソースからのみインストール

ホワイトリスト例:
  許可:
    - react (npm公式)
    - fastapi (PyPI公式)
    - 既知の安全なライブラリ

  禁止:
    - 不明なソースのパッケージ
    - セキュリティ脆弱性が報告されているもの
    - ダウンロード数が極端に少ないもの
```

#### 7. Rate Limiting（暴走防止）

```yaml
制限:
  - 1日あたりの自己拡張回数: 最大3回
  - 1週間あたりの新エージェント追加: 最大10個
  - 1ヶ月あたりのコード変更行数: 最大10,000行

理由:
  - マザーAIの暴走を防ぐ
  - 異常な変更を早期検知
  - システムの安定性維持

超過時の対応:
  - 自動的に拡張を停止
  - 管理者に警告通知
  - 手動で制限解除が必要
```

#### 8. 緊急停止スイッチ（Kill Switch）

```yaml
機能:
  - 管理画面に「緊急停止」ボタンを配置
  - マザーAIの自己拡張機能を即座に無効化
  - すべての自動変更を停止

発動条件（自動）:
  - セキュリティスキャンで重大な脅威検出
  - API料金が1日で10万円を超過
  - システムエラー率が50%を超過
  - 外部からの不正アクセス検知

発動後:
  - すべての自動拡張を停止
  - 管理者に緊急通知
  - 最後の安全なバージョンに自動ロールバック
  - 詳細な調査レポート生成
```

---

### 12.7 自己拡張モード選択機能（ユーザー設定）

**目的:**
- ユーザーが自分のスキルレベルと管理スタイルに応じて、自己拡張の承認レベルを選択可能
- 初心者は安全な手動モード、上級者は効率的な自動モードを選択できる

#### モード一覧

```yaml
🔴 手動モード（最も安全 - 初心者推奨）:

  特徴:
    - すべての自己拡張に人間の承認が必要
    - バグ修正でも必ず承認プロセスを経由
    - 最も安全だが、拡張速度は遅い

  承認が必要な変更:
    ✅ Critical: 必ず承認
    ✅ Medium: 必ず承認
    ✅ Low: 必ず承認（通常モードと異なる）

  推奨ユーザー:
    - マザーAIを初めて使う方
    - システムの変更を完全にコントロールしたい方
    - 学習目的で各変更を確認したい方

🟡 半自動モード（推奨 - バランス重視）:

  特徴:
    - 重要な変更は承認必要、軽微な変更は自動
    - 安全性と効率性のバランスが取れている
    - ほとんどのユーザーに推奨

  承認が必要な変更:
    ✅ Critical: 必ず承認
    ✅ Medium: 必ず承認
    ⚙️ Low: 自動承認（事後通知あり）

  自動承認される変更例:
    - バグ修正
    - パフォーマンス最適化
    - ログ出力の改善
    - ドキュメント更新

  推奨ユーザー:
    - マザーAIに慣れてきた方
    - 開発効率を重視する方
    - ある程度の自動化を許容できる方

🟢 自動モード（上級者向け - 効率重視）:

  特徴:
    - セキュリティスキャンを通過すれば自動実行
    - サンドボックステスト必須
    - 最も速く拡張するが、リスクもある
    - 問題発生時は自動ロールバック

  承認が必要な変更:
    🔴 Critical: 必ず承認（変更なし）
    ⚙️ Medium: 自動承認（サンドボックステスト必須）
    ⚙️ Low: 自動承認

  安全装置:
    ✅ サンドボックステスト（必須）
    ✅ セキュリティスキャン（必須）
    ✅ 自動ロールバック（エラー時）
    ✅ 変更通知（事後メール）

  推奨ユーザー:
    - システムに精通している方
    - 開発速度を最優先する方
    - 問題発生時に対応できる技術力がある方
```

#### モード切り替えUI

```yaml
実装場所:
  - プロフィール設定ページ（/profile）
  - 管理者設定ページ（管理者用）

UI要素:
  ラジオボタン選択:
    ○ 🔴 手動モード（最も安全）
    ○ 🟡 半自動モード（推奨）
    ○ 🟢 自動モード（上級者向け）

  説明文:
    各モードの詳細説明を表示

  警告メッセージ:
    「自動モードは上級者向けです。マザーAIが自動的にシステムを変更します。」

変更時の確認:
  - モードを自動に変更する際は確認ダイアログ
  - 「本当に自動モードに切り替えますか？」
  - リスクの説明を表示
```

#### デフォルト設定

```yaml
新規ユーザー:
  - デフォルト: 🔴 手動モード
  - 理由: 安全性を最優先

1ヶ月以上使用したユーザー:
  - 推奨: 🟡 半自動モード
  - 自動的に提案（強制はしない）

管理者:
  - デフォルト: 🟡 半自動モード
  - 管理者判断で自由に変更可能
```

#### データモデル追加

```python
# app/models/models.py の User モデルに追加

class SelfExpansionMode(enum.Enum):
    manual = "manual"          # 手動モード
    semi_auto = "semi_auto"    # 半自動モード
    auto = "auto"              # 自動モード

class User(Base):
    # ... 既存フィールド ...

    # 自己拡張モード設定
    self_expansion_mode = Column(
        Enum(SelfExpansionMode),
        default=SelfExpansionMode.manual,  # 新規ユーザーは手動モード
        nullable=False
    )
```

#### 承認フロー実装

```python
# app/services/expansion_approval.py

class ExpansionApprovalService:
    """
    自己拡張の承認フローを管理
    """

    async def should_approve_automatically(
        self,
        user: User,
        change_level: str  # "critical", "medium", "low"
    ) -> bool:
        """
        変更を自動承認すべきか判定
        """
        mode = user.self_expansion_mode

        if mode == SelfExpansionMode.manual:
            # 手動モード: すべて承認必要
            return False

        elif mode == SelfExpansionMode.semi_auto:
            # 半自動モード: Lowのみ自動
            return change_level == "low"

        elif mode == SelfExpansionMode.auto:
            # 自動モード: Critical以外は自動
            return change_level != "critical"

        return False

    async def request_approval(
        self,
        user: User,
        expansion: SystemExpansion
    ) -> bool:
        """
        承認をリクエスト
        """
        if await self.should_approve_automatically(user, expansion.change_level):
            # 自動承認
            expansion.status = "approved"
            expansion.approved_by = "system_auto"
            expansion.approved_at = datetime.utcnow()

            # ユーザーに事後通知
            await self.send_notification(user, expansion, auto_approved=True)

            return True
        else:
            # 人間の承認待ち
            expansion.status = "pending_approval"

            # ユーザーに承認依頼通知
            await self.send_approval_request(user, expansion)

            return False
```

#### 通知システム

```yaml
手動モード:
  - 承認依頼: メール + アプリ内通知（即座）
  - 承認後: メール + アプリ内通知

半自動モード:
  - 承認依頼（Medium/Critical）: メール + アプリ内通知（即座）
  - 自動承認（Low）: 1日1回まとめてメール

自動モード:
  - 承認依頼（Critical）: メール + アプリ内通知（即座）
  - 自動承認（Medium/Low）: 1日1回まとめてメール
  - 問題発生時: 即座にメール + アプリ内通知
```

---

### 12.8 Phase 1エージェント: 要件定義能力の目標

**ベンチマーク:** レコンX（レクシン AI for kintone）同等レベル

レコンXは、kintoneアプリ開発のための要件定義支援AIで、Claude APIと連携して以下の能力を持ちます：
- AIとの対話を通じた要件の引き出し
- 機能要件書の自動生成
- 業務フロー図の生成
- システム構成図の生成
- 既存システムからのリバースエンジニアリング

マザーAIのPhase 1エージェントは、**レコンX同等レベルの要件定義能力**を目標とします。

#### 実装する主要機能

```yaml
1. 深掘り質問による要件抽出:
  能力:
    - 5W1Hを徹底（What, Why, Who, When, Where, How）
    - 曖昧な要件を具体化する質問
    - ビジネス目標とシステム要件の紐付け
    - ステークホルダー分析

  例:
    ユーザー: 「ECサイトを作りたい」
    Phase 1: 「ECサイトですね。以下について教えてください：
              1. どのような商品を扱いますか？
              2. 想定ユーザー数は？
              3. 決済方法は？（クレカ、代引き等）
              4. 在庫管理は必要ですか？
              5. 既存システムとの連携は？」

2. 構造化された要件定義書の生成:
  生成物:
    ✅ 機能要件書（Functional Requirements）
       - ユーザーストーリー形式
       - 優先度付き機能リスト
       - 受け入れ基準

    ✅ 非機能要件書（Non-Functional Requirements）
       - パフォーマンス要件
       - セキュリティ要件
       - スケーラビリティ要件

    ✅ ユースケース図
       - アクター定義
       - 主要ユースケース
       - システム境界

    ✅ 業務フロー図
       - 現状の業務フロー
       - 改善後の業務フロー
       - ボトルネック特定

3. ドメイン知識の活用:
  対応領域:
    - ECサイト（商品管理、カート、決済）
    - SaaSアプリ（認証、課金、マルチテナント）
    - 社内システム（ワークフロー、承認、権限管理）
    - 予約システム（カレンダー、リソース管理）
    - マッチングサービス（検索、フィルタ、マッチング）

  提案機能:
    - 業界ベストプラクティスの提案
    - 必要なセキュリティ対策の自動提案
    - パフォーマンス最適化の提案
    - 一般的な落とし穴の警告

4. 対話的な要件確認:
  機能:
    - 理解度チェック質問
    - 矛盾点の指摘
    - 代替案の提案
    - リスク分析

  例:
    「在庫管理機能が必要とのことですが、リアルタイム在庫
     更新が必要ですか？それとも日次バッチ更新で十分ですか？
     リアルタイムの場合、開発コストが約30%増加します。」

5. 技術要件への変換:
  出力:
    - データモデル設計（ER図）
    - API設計（エンドポイント一覧）
    - 画面遷移図
    - システム構成図
    - 必要な技術スタック提案
```

#### レコンXとの違い（優位性）

```yaml
レコンXの特徴:
  - kintoneに特化
  - kintoneアプリの設計・設定が中心
  - プラグイン提案

マザーAIの優位性:
  ✅ フルスタック開発に対応
     - フロントエンド（React）
     - バックエンド（FastAPI）
     - データベース設計
     - デプロイまで一貫

  ✅ コード生成まで実行（Phase 2へ連携）
     - レコンXは設計まで
     - マザーAIは実装まで

  ✅ 自己改善機能（Phase 4）
     - ユーザーフィードバックから学習
     - 要件定義能力自体が進化

  ✅ マルチドメイン対応
     - kintoneに限定されない
     - あらゆるWebアプリに対応
```

#### 実装アプローチ

```yaml
Phase 1エージェントのプロンプト設計:

1. システムプロンプト:
   - 役割: 経験豊富な要件定義エンジニア
   - 専門性: 10年以上のWebアプリ開発経験
   - スタイル: 具体的な質問、段階的な深掘り

2. プロンプトキャッシング:
   - ドメイン知識（EC、SaaS等）をキャッシュ
   - ベストプラクティス集をキャッシュ
   - 50%のコスト削減

3. Few-shot Learning:
   - 優れた要件定義の例を含める
   - 質問パターンの例示
   - 要件定義書のテンプレート

4. チェーン・オブ・ソート（CoT）:
   - ステップバイステップで思考
   - 「まず、〇〇を確認します」
   - 「次に、××について質問します」
```

#### 成功指標（KPI）

```yaml
定量指標:
  - 要件の完全性: 90%以上（必要要件の網羅率）
  - ユーザー満足度: 4.5/5.0以上
  - 要件確定までの対話ターン数: 平均15-20ターン
  - Phase 2への移行率: 95%以上（要件定義から実装へ）

定性指標:
  - 初心者でも理解しやすい質問
  - 適切な深掘り（深すぎず浅すぎず）
  - ビジネス視点とエンジニア視点の両立
  - 「プロのエンジニアと話している感覚」
```

---

### 実装優先度

```yaml
MVP（10-14日）:
  ✅ 人間の承認フロー（必須）
  ✅ 基本的なセキュリティスキャン
  ✅ Gitバージョン管理
  ✅ 変更ログ記録
  ✅ Phase 1エージェント基本実装（レコンX同等レベル）

Phase 2（30-60日）:
  ✅ サンドボックス環境
  ✅ 自動ロールバック
  ✅ Rate Limiting
  ✅ 外部依存関係チェック
  ✅ Phase 1エージェント高度化（Few-shot改善）

Phase 3（6ヶ月）:
  ✅ 高度なセキュリティスキャン
  ✅ 緊急停止スイッチ
  ✅ 完全な監査証跡
  ✅ AIによる異常検知
  ✅ Phase 1エージェント自己学習機能
```

---

**作成日**: 2025年11月5日
**バージョン**: 1.0
**作成者**: レコンX（要件定義クリエイター）
